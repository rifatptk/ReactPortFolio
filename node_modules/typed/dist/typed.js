'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function ok(data) {
  return { ok: true, data };
}
function err(...errors) {
  return { ok: false, errors };
}
function isPlainObject(value) {
  return value !== null && typeof value === "object" && !Array.isArray(value);
}
function toMismatchMsg(expected, actual) {
  return `Expecting type '${expected}'. Got type '${actual}'.`;
}
function toErr(message, path = []) {
  return { message, path };
}
function mapErrorKey(key, ...errors) {
  return errors.map(function(err2) {
    return { ...err2, path: [key.toString(), ...err2.path] };
  });
}
function getTypeOf(x) {
  return Object.prototype.toString.call(x).slice(8, -1).toLowerCase();
}
function map(base, onSuccess) {
  return function(x) {
    const result = base(x);
    return result.ok ? onSuccess(result.data) : result;
  };
}
function refine(base, onSuccess) {
  return map(base, function(data) {
    return ok(onSuccess(data));
  });
}

function string(x) {
  if (typeof x === "string")
    return ok(x);
  return err(toErr(toMismatchMsg("string", getTypeOf(x))));
}
function number(x) {
  if (typeof x !== "number")
    return err(toErr(toMismatchMsg("number", getTypeOf(x))));
  if (!Number.isFinite(x))
    return err(toErr(`Expecting value to be a finite 'number'.`));
  return ok(x);
}
function boolean(x) {
  if (typeof x === "boolean")
    return ok(x);
  return err(toErr(toMismatchMsg("boolean", getTypeOf(x))));
}
function date(x) {
  if (!(x instanceof Date))
    return err(toErr(toMismatchMsg("date", getTypeOf(x))));
  if (!Number.isFinite(x.getDate()))
    return err(toErr(`Expecting date to be valid.`));
  return ok(x);
}
function regex(regex2) {
  return map(string, function(input) {
    return regex2.test(input) ? ok(input) : err(toErr(`Expecting value to match '${regex2.toString()}'.`));
  });
}
function array(type) {
  return function(x) {
    if (!Array.isArray(x))
      return err(toErr(toMismatchMsg("array", getTypeOf(x))));
    const arr = [];
    const errors = [];
    for (let i = 0; i < x.length; i++) {
      const result = type(x[i]);
      if (result.ok) {
        arr.push(result.data);
      } else {
        errors.push(...mapErrorKey(i, ...result.errors));
      }
    }
    return errors.length ? err(...errors) : ok(arr);
  };
}
function object(shape) {
  const entries = Object.entries(shape);
  return function(x) {
    if (!isPlainObject(x))
      return err(toErr(toMismatchMsg("object", getTypeOf(x))));
    const obj = /* @__PURE__ */ Object.create(null);
    const errors = [];
    for (let i = 0; i < entries.length; i++) {
      const [key, type] = entries[i];
      const result = type(x[key]);
      if (result.ok) {
        obj[key] = result.data;
      } else {
        errors.push(...mapErrorKey(key, ...result.errors));
      }
    }
    return errors.length ? err(...errors) : ok(obj);
  };
}
function record(key, value) {
  return function(x) {
    if (!isPlainObject(x))
      return err(toErr(toMismatchMsg("object", getTypeOf(x))));
    const obj = /* @__PURE__ */ Object.create(null);
    const errors = [];
    const values = Object.entries(x);
    for (let i = 0; i < values.length; i++) {
      const [k, v] = values[i];
      const kResult = key(k);
      if (!kResult.ok) {
        errors.push(...mapErrorKey(k, ...kResult.errors));
        continue;
      }
      const vResult = value(v);
      if (vResult.ok) {
        obj[k] = vResult.data;
      } else {
        errors.push(...mapErrorKey(k, ...vResult.errors));
      }
    }
    return errors.length ? err(...errors) : ok(obj);
  };
}
function literal(constant) {
  return function(x) {
    return constant === x ? ok(x) : err(toErr(`Expecting literal '${constant}'. Got '${x}'.`));
  };
}
function nullable(type) {
  return function(x) {
    return x === null ? ok(x) : type(x);
  };
}
function optional(type) {
  return function(x) {
    return typeof x === "undefined" ? ok(x) : type(x);
  };
}
function enums(e) {
  const values = Object.values(e);
  return function(x) {
    return values.includes(x) ? ok(x) : err(toErr(`Expecting value to be one of '${values.join(", ")}'. Got '${x}'.`));
  };
}
function tuple(...types) {
  return function(x) {
    if (!Array.isArray(x))
      return err(toErr(toMismatchMsg("array", getTypeOf(x))));
    const arr = [];
    const errors = [];
    for (let i = 0; i < types.length; i++) {
      const result = types[i](x[i]);
      if (result.ok) {
        arr.push(result.data);
      } else {
        errors.push(...mapErrorKey(i, ...result.errors));
      }
    }
    return errors.length ? err(...errors) : ok(arr);
  };
}
function union(...types) {
  return function(x) {
    const errors = [];
    for (let i = 0; i < types.length; i++) {
      const result = types[i](x);
      if (result.ok) {
        return result;
      }
      errors.push(...result.errors);
    }
    return err(...errors);
  };
}
function intersection(...types) {
  return function(x) {
    const obj = /* @__PURE__ */ Object.create(null);
    const errors = [];
    for (let i = 0; i < types.length; i++) {
      const result = types[i](x);
      if (result.ok) {
        Object.assign(obj, result.data);
      } else {
        errors.push(...result.errors);
      }
    }
    return errors.length ? err(...errors) : ok(obj);
  };
}
function any(x) {
  return ok(x);
}
function defaulted(type, fallback) {
  return function(x) {
    return typeof x === "undefined" ? ok(fallback) : type(x);
  };
}
function asString(x) {
  return string(String(x));
}
function asNumber(x) {
  return number(Number(x));
}
function asDate(x) {
  if (typeof x === "string" || typeof x === "number")
    return date(new Date(x));
  return date(x);
}

exports.any = any;
exports.array = array;
exports.asDate = asDate;
exports.asNumber = asNumber;
exports.asString = asString;
exports.boolean = boolean;
exports.date = date;
exports.defaulted = defaulted;
exports.enums = enums;
exports.err = err;
exports.intersection = intersection;
exports.literal = literal;
exports.map = map;
exports.nullable = nullable;
exports.number = number;
exports.object = object;
exports.ok = ok;
exports.optional = optional;
exports.record = record;
exports.refine = refine;
exports.regex = regex;
exports.string = string;
exports.toErr = toErr;
exports.tuple = tuple;
exports.union = union;
