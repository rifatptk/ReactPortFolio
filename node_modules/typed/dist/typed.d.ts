declare type Err = {
    readonly message: string;
    path: string[];
};
declare type Success<T> = {
    ok: true;
    data: T;
};
declare type Failure = {
    ok: false;
    errors: Err[];
};
declare type Result<T> = Success<T> | Failure;
declare type Type<T = any> = (x: any) => Result<T>;
declare type Shape = {
    [key: string]: Type;
};
declare type PlainObject = {
    [key: string]: any;
};
declare type Infer<T> = T extends Shape ? {
    [K in keyof T]: Infer<T[K]>;
} : T extends Type<infer U> ? U : never;
declare type Literal = string | number | boolean | null;
declare type Enum = {
    [key: string]: string | number;
};
/**
 * Borrowed from `superstruct`
 * @see https://github.com/ianstormtaylor/superstruct/blob/28e0b32d5506a7c73e63f7e718b23977e58aac18/src/utils.ts#L393
 */
declare type InferTuple<Tuple extends Type[], Length extends number = Tuple["length"]> = Length extends Length ? number extends Length ? Tuple : _InferTuple<Tuple, Length, []> : never;
declare type _InferTuple<Tuple extends Type[], Length extends number, Accumulated extends any[], Index extends number = Accumulated["length"]> = Index extends Length ? Accumulated : _InferTuple<Tuple, Length, [...Accumulated, Infer<Tuple[Index]>]>;
/**
 * Borrowed from `superstruct`
 * @see https://github.com/ianstormtaylor/superstruct/blob/28e0b32d5506a7c73e63f7e718b23977e58aac18/src/utils.ts#L200
 */
declare type UnionToIntersection<U> = (U extends any ? (arg: U) => any : never) extends (arg: infer I) => void ? I : never;

/**
 * Create a new `Success` result.
 * @since 3.0.0
 */
declare function ok<T>(data: T): Success<T>;
/**
 * Create a new `Failure` result.
 * @since 3.0.0
 */
declare function err(...errors: Err[]): Failure;
/**
 * Create a new error object.
 *
 * @param message - The error message.
 * @param path - The path to the error.
 * @returns The error object.
 * @since 1.0.0
 */
declare function toErr(message: string, path?: string[]): Err;
/**
 * Create a new type from a given base type.
 * It ensures that the base type passes validation before carrying on.
 *
 * @example
 * ```ts
 * const emailType = T.map(T.string, (value) =>
 *  EMAIL_REGEX.test(value)
 *    ? T.ok(value)
 *    : T.err(T.toError('Expecting string to be a valid email address'))
 * )
 * ```
 *
 * @param base - The base type.
 * @param onSuccess - The mapping function.
 * @returns The new type.
 * @since 1.0.0
 */
declare function map<I, O>(base: Type<I>, onSuccess: (data: I) => Result<O>): Type<O>;
/**
 * It allows you to further process the result of a type.
 * Specially usefull when trimming, upper casing, etc.
 * Keep in mind that the output type must be the same as the input type.
 *
 * @example
 * ```ts
 * const lowerTrim = T.refine(T.string, (value) => value.trim().toLowerCase())
 * lowerTrim('  HELLO WORLD  ') // Ok('hello world')
 * ```
 *
 * @param base - The base type.
 * @param onSuccess - The mapping function.
 * @returns The new type.
 * @since 1.3.0
 */
declare function refine<T>(base: Type<T>, onSuccess: (data: T) => T): Type<T>;

/**
 * Check wether a given value is of type string.
 *
 * @param value - The value to check.
 * @returns The result.
 * @since 1.0.0
 */
declare function string(x: any): Result<string>;
/**
 * Check wether a given value is of type number.
 * It also makes sure that the value is a finite number.
 *
 * @param value - The value to check.
 * @returns The result.
 * @since 1.0.0
 */
declare function number(x: any): Result<number>;
/**
 * Check wether a given value is of type boolean.
 *
 * @param value - The value to check.
 * @returns The result.
 * @since 1.0.0
 */
declare function boolean(x: any): Result<boolean>;
/**
 * Check wether a given value is of type Date.
 * It also makes sure that the date is a valid.
 *
 * @param value - The value to check.
 * @returns The result.
 * @since 1.0.0
 */
declare function date(x: any): Result<Date>;
/**
 * Check wether a given value is a string and matches a given regular expression.
 *
 * @param regex - The regex to check against.
 * @returns The result.
 * @since 1.3.0
 */
declare function regex(regex: RegExp): Type<string>;
/**
 * Create a new typed function that will check wether a given value is an array and every element of the array passes the given type.
 *
 * @example
 * ```ts
 * const arrayOfStrings = T.array(T.string)
 * arrayOfStrings(['hello', 'world']) // Success
 * arrayOfStrings(['hello', 123]) // Failure
 * ```
 *
 * @param type - The type of the items in the array.
 * @returns The new type.
 * @since 1.0.0
 */
declare function array<T>(type: Type<T>): Type<T[]>;
/**
 * Create a new typed function from a given shape.
 * The shape can be as deep as needed.
 *
 * @example
 * ```ts
 * const postType = T.object({
 *   title: T.string,
 *   body: T.string,
 *   tags: T.array(T.string),
 *   author: T.object({
 *     name: T.string,
 *   })
 * })
 * ```
 *
 * @param shape - The shape of the object.
 * @returns The new type.
 * @since 1.0.0
 */
declare function object<T extends Shape>(shape: T): Type<Infer<T>>;
/**
 * Creates a new typed function what will check that every key inside an object
 * matches the key type and every value matches the value type. It is the equivalent
 * to TypeScript's Record type
 *
 * @example
 * ```ts
 * const rec = T.record(T.string, T.object({ name: T.string })) // Record<string, { name: string }>
 * const data = {
 *  "1": { name: "john" },
 *  "2": { name: "doe"}
 * }
 * rec(data) // ok
 * ```
 *
 * @param key - The type of the key
 * @param value - The type of the value
 * @returns The new type
 * @since 3.1.0
 */
declare function record<K extends string, T>(key: Type<K>, value: Type<T>): Type<Record<K, T>>;
/**
 * Create a new typed function from a given constant.
 * It ensures that the value is equal to the given constant.
 *
 * @example
 * ```ts
 * const constant = T.literal('hello')
 * constant('hello') // Success
 * constant('world') // Failure
 * ```
 *
 * @param value - The constant to check.
 * @returns The new type.
 * @since 1.0.0
 */
declare function literal<T extends Literal>(constant: T): Type<T>;
/**
 * Create a new typed function from a given type that will succeed if the value is null.
 *
 * @example
 * ```ts
 * const nullable = T.nullable(T.string)
 * nullable(null) // Success
 * nullable('hello') // Success
 * nullable(123) // Failure
 * ```
 *
 * @param type - The type to check.
 * @returns The new type.
 * @since 1.0.0
 */
declare function nullable<T>(type: Type<T>): Type<T | null>;
/**
 * Create a new typed function from a given type that will succeed if the value is undefined.
 *
 * @example
 * ```ts
 * const optional = T.optional(T.string)
 * optional(undefined) // Success
 * optional('hello') // Success
 * optional(123) // Failure
 * ```
 *
 * @param type - The type to check.
 * @returns The new type.
 * @since 1.0.0
 */
declare function optional<T>(type: Type<T>): Type<T | undefined>;
/**
 * Create a new typed function from a given TypeScript Enum.
 *
 * @example
 * ```ts
 * enum Role {
 *   ADMIN,
 *   USER,
 * }
 *
 * const role = T.enums(Role)
 * role(Role.ADMIN) // Success
 * role(Role.USER) // Success
 * role(Role.GUEST) // Failure
 * ```
 *
 * @param enumType - The enum to check.
 * @returns The new type.
 * @since 1.0.0
 */
declare function enums<T extends Enum, K extends keyof T>(e: T): Type<T[K]>;
/**
 * Create a new typed function from a list of types.
 * A tuple is like a fixed length array and every item should be of the specified type.
 *
 * @example
 * ```ts
 * const tuple = T.tuple(T.string, T.number)
 * tuple(['hello', 123]) // Success
 * tuple(['hello', 'world']) // Failure
 * ```
 *
 * @param types - The types to check.
 * @returns The new type.
 * @since 1.0.0
 */
declare function tuple<A extends Type, B extends Type[]>(...types: [A, ...B]): Type<[Infer<A>, ...InferTuple<B>]>;
/**
 * Create a new typed function from a list of types.
 * This function will succeed if the value is any of the given types.
 *
 * @example
 * ```ts
 * const anyOf = T.union(T.string, T.number, T.boolean)
 * anyOf('hello') // Success
 * anyOf(123) // Success
 * anyOf(true) // Success
 * anyOf(null) // Failure
 * ```
 * @param types - The types to check.
 * @returns The new type.
 * @since 1.0.0
 */
declare function union<A extends Type, B extends Type[]>(...types: [A, ...B]): Type<Infer<A> | InferTuple<B>[number]>;
/**
 * Create a new typed function which combines multiple types into one.
 *
 * @example
 * ```ts
 * const a = T.object({ name: T.string  })
 * const b = T.object({ age: T.number})
 * const c = T.intersection(a, b)
 *
 * c({ name: 'hello', age: 123 }) // Success
 * c({ name: 'hello', age: 'world' }) // Failure
 * c({name: 'hello'}) // Failure
 * ```
 *
 * @param types - The types to check.
 * @returns The new type.
 * @since 1.2.0
 */
declare function intersection<A extends Type<PlainObject>, B extends Type<PlainObject>[]>(...types: [A, ...B]): Type<Infer<A> & UnionToIntersection<InferTuple<B>[number]>>;
/**
 * A passthrough function which returns its input marked as any.
 * Do not use this unless you really need to, it defeats the purpose of this library.
 *
 * @since 1.0.0
 */
declare function any(x: any): Result<any>;
/**
 * Create a new typed function from a given type that will return a fallback value if the input value is undefined.
 *
 * @example
 * ```ts
 * const withFallback = T.defaulted(T.number, 0)
 * withFallback(undefined) // Success(0)
 * withFallback(123) // Success(123)
 * withFallback('hello') // Failure
 * ```
 *
 * @param type - The type to check.
 * @param fallback - The fallback value.
 * @returns The new type.
 * @since 1.0.0
 */
declare function defaulted<T>(type: Type<T>, fallback: T): Type<T>;
/**
 * Coerce first, then check if value is a string.
 *
 * @param x - The value to check.
 * @returns The result.
 * @since 1.0.0
 */
declare function asString(x: any): Result<string>;
/**
 * Coerce first, then check if value is a number.
 *
 * @param x - The value to check.
 * @returns The result.
 * @since 1.0.0
 */
declare function asNumber(x: any): Result<number>;
/**
 * Coerce first, then check if value is a valid date.
 *
 * @param x - The value to check.
 * @returns The result.
 * @since 1.0.0
 */
declare function asDate(x: any): Result<Date>;

export { Err, Failure, Infer, Result, Success, Type, any, array, asDate, asNumber, asString, boolean, date, defaulted, enums, err, intersection, literal, map, nullable, number, object, ok, optional, record, refine, regex, string, toErr, tuple, union };
